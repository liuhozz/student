1.常量:	
	在程序运行的过程中不会发生改变的量.

	①字面值常量: 12  2.3  'a' "str" true/false
	②自定义常量


------------------------了解的内容----------------------------
2.进制
	二进制: 0b0011
	八进制: 0123
	十六进制: 0x100
	十进制: 100

	任意进制转换成十进制:
		系数*基数的权次幂

		系数:每一位上的数
		基数:几进制,基数就是几
		权:从右边开始,从0开始编号

	十进制转换成任意进制:
		除基倒取余数

---------------------------------------------------------------
3.原码反码补码:

	原码
	  |--符号位不变,其他各位取反(0变成1,1变成0)
	  |
	反码
	  |--加一
	  |
	补码

	正数: 它的原码反码补码都是一样的
	负数: 原码-->反码-->补码

---------------------------------------------------------------

4.变量定义的格式:
	数据类型 变量名=变量值;

5.数据类型:
	①引用数据类型
	②基本数据类型
		四类八种:
			整数型:byte(-128~127) short int long
			浮点型:float double
			字符型:char: 'a'=97  'A'=65  '0'=48
			布尔型:boolean  true/false

6. 整数默认是int类型
   小数默认是double类型

7.使用变量的注意事项:
	1.在同一个作用域之内,不能定义相同名字的变量
	2.在使用变量前必须要赋值.
	3.一条语句可以定义多个变量
	4.一条语句最好只声明一个变量就好了!


8.数据类型的转换:
	1.隐式转换:
		两个不相同数据类型的变量进行运算时, 会把小的数据类型提升成大的数据类型,再进行运算.
		把小的数据类型的值存储到大的数据类型的变量中!

		byte b=10;
		int x=b;

	2.强制类型转换:
		把大的数据类型存储到小的数据类型的变量中!

		(数据类型)值;

		int x=10;

		byte b = (byte)x;

	3.注意事项:
		1.byte short char 这三个类型的变量在进行运算的时候,会自动类型提升到int类型
		
		2.常量优化机制:
			byte b=3+4; 编译器在编译这句代码的时候它可以知道两个常量相加的值就是7,
			所以,它在编译的时候就把这一步运算提前做完, 把结果编译成字节码,内容就是
			byte b=7; 这样,程序在运行的时候就不需要再做相加的运算这一步了,可以提高程序的效率!


9.float类型取值范围为什么比long类型的要大?
	因为底层的存储方式不同!

10.字符和字符串进行运算时:
		1.每一个字符都对应一个ASCII码值.
		如果直接输出,那就是字符
		如果进行运算,就是使用对应的码值

		2.字符串与任意类型进行相加,都会产生一个新的字符串!


11.字符类型:
	1.字符类型的变量的赋值方式:
		1.可以赋值单引号括起来的字符: 'a'
		2.可以是字符对应的码值: 97

		但是,推荐使用第一种方式赋值!

	2.字符类型是可以存储中文的!字符类型是占了两个字节的,中文也是两个字节的!


	

12.运算符:
	1.算术运算符:	
		+ - * /  %
		/:除法运算, 两个整数相除,是得不到小数的,想得到小数, 可以把其中一个变成小数再相除!

		%: 还是做除法运算,但是取的是余数!

		++: 对变量自身加一
		--: 对变量自身减一

		++/-- 在变量的左边,先对变量进行自增/自减,然后再把自增/自减之后的值进行其他运算

		++/-- 在变量的右边,,先对变量进行自增/自减,然后再把自增/自减之前的值进行其他运算

		++/--是一个特殊的运算符,它们都具有一个特别的功能,就是隐含着强制类型转换的功能!

	2.赋值运算符:
		=,+=,-=,*=,/=,%=

		左边必须是变量
		除了=运算符,其他赋值运算符都隐含着强制转换的功能!

	3.关系运算符:
		>  >=  <   <=  ==  != 
		①关系运算符运算的结果都是boolean类型的
		②比较相等用==, 不要用=
