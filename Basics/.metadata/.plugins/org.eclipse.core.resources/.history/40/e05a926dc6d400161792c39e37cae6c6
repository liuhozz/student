charAt(int intdex);		   获取指定索引位置的字符
indexOf(int ch);		   返回指定字符在此字符串中第一次出现处的索引
indexOF(String str);		   返回指定字符串在此字符串中第一次出现处的索引
indexOf(int ch,int fromIndex);	   返回指定字符在此字符串中从指定位置后第一次出现处的索引
indexOf(String str ,int fromIndex);返回指定字符串在此字符串中从指定位置后第一次出现处的索引
lastIdexOf			   与前几个相反  是最后一次出现处的索引
substring (int start);		   从指定位置开始截取字符串,默认到末尾
substring (int start,int end);	   从指定的位置开始到指定位置结束截取字符串

indexOf				   方法如果不存在则返回-1
 
replace(char old,char new) 	   将old替换成new(替换字符)
replace(String old,String new)	   将old替换成new(替换字符串)

trim();				   去掉两端的空格  中间的不去

compareTo();			   按unicode码表值来比较字符串
compareToIgnoreCase();		   不区分大小写的比较 


boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写
boolean contains(String str):判断大字符串中是否包含小字符串
boolean startsWith(String str):判断字符串是否以某个指定的字符串开头
boolean endsWith(String str):判断字符串是否以某个指定的字符串结尾
boolean isEmpty():判断字符串是否为空。

byte[] getBytes():把字符串转换为字节数组。
char[] toCharArray():把字符串转换为字符数组。
static String valueOf(char[] chs):把字符数组转成字符串。
static String valueOf(int i):把int类型的数据转成字符串。
注意：String类的valueOf方法可以把任意类型的数据转成字符串。
	
	
String toLowerCase():把字符串转成小写。(了解)
String toUpperCase():把字符串转成大写。
String concat(String str):把字符串拼接。




StringBuffer

reverse();    	字符串的反转功能
sort();		数组自动排序

StringBuffer的substring()返回的是String 而不是StringBuffer

JDK5新特性之一自动装箱,自动拆箱(自动拆箱时如果值不在byte范围内则会在堆中创建对象在byte范围内会自动获取在常量池中获取已有的地址值)
正则表达式:是指一个用来描述或者匹配一系列符合某个语法规则的字符串的单个字符串.其实就是一种规则.有自己特殊的应用.
比如:注册账号是有限制  而这个限制就是用正则表达式做的
[]代表单个字符
[abc]表示单个字符只能为abc
[a-cd-z]表示单个字符只能在a-cd-z的范围内
[a-c&&[bc]]表示两个范围的交集
[a-z&&[^bc]表示a-z的范围内除了bc之外都可以

前面要加\转义字符
.代表的是任意字符
\d:数字0-9
\D:非数字
\s:空白字符如[\t \n \x0B \f \r]
\S:非空白字符
\w:单词字符[a-zA-Z_0-9](_也是单词字符a-zA-Z&_&0-9)
\W:非单词字符

数量词
x? 	:X出现一次或一次也没有
x* 	:X零次或多次
x+ 	:X一次或多次
x{n}    :X恰好n次
x{n,}	:X至少n次
x{n,m}	:X至少n次,但不超过m次


地址传递
值传递math 
random的带参构造  中传的种子是什么





system
gc();手挡的垃圾回收器
arraycopy();从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。
currentTimeMillis();返回以毫秒为单位的当前时间

BigInteger:可以让超过intteger范围的数据进行运算
isprobableprime();判断是否为
里面还有进行+-*/的运算的方法
divideAndRemainder();返回一个有除法和模运算的结果的数组

java.util的 Date类Date d=new date();返回的是当前的时间

		  Date d=new date(0);返回的是 1970年1月1日 0:00:00 但打印出的是08:00:00 因为我们这里是东8区  时区不同 

















1.快捷键:
	ctrl+c:复制
	ctrl+v:粘贴
	ctrl+z:撤销
	ctrl+x:剪切
	ctrl+s:保存
	ctrl+a:全选

2.DOS命令行:(了解)
	cd: 切换到指定目录
	cd..: 返回上一级目录
	cd /: 返回根目录
	md: 创建文件夹
	rd: 删除文件夹
	dir: 显示当前路径下的所有文件和文件夹
	cls: 清屏
	del: 删除文件
	exit: 退出

3.JDK下载和安装(了解)


4.path环境配置:(了解)
	第一种方式:(不推荐)
		把JDK安装路径中的bin路径添加到path路径中
	
	第二种方式:
		①新建一个环境变量: JAVA_HOME = JDK安装路径(不包含bin)
		②把JAVA_HOME环境变量添加到path环境变量中: %JAVA_HOME%\bin;

5.HelloWorld案例(掌握)

6.注意事项:
	①注意文件后缀名是.java, 必须要显示文件后缀名
	②严格区分大小写
	③不要把标点符号写成中文的


7.java语法规范:
	①左大括号一般要写在句尾
	②遇到左大括号, 下一行要缩进一个Tab键
	③运算符左右加空格
	④左大括号前面要加空格

8.注释:
	对代码的解释说明的文字
	①单行注释: 可以嵌套使用
	②多行注释: 不可以嵌套使用

9.关键字:(掌握)
	在java中具有特定含义的单词:
		特点:全部都是小写的. 在EditPlus中显示蓝色的!


10.标识符:(掌握)
	起名字
	①组成: 字母(正常的文字),数字,下划线,$符号
	②规则: 不能以数字开头, 不能使用关键字,不能使用非法字符.

11.命名规则:(重点掌握)

	类或者接口:所有单词首字母大写

	包:所有单词小写, 包名一般使用域名倒着写: 域名是:itheima.com--->包名: com.itheima
		包实际上就是文件夹

	方法名或者变量名:第一个单词小写, 后面的所有单词首字母大写

	常量: 所有单词大写,有多个单词用下划线隔开

1.常量:	
	在程序运行的过程中不会发生改变的量.

	①字面值常量: 12  2.3  'a' "str" true/false
	②自定义常量


------------------------了解的内容----------------------------
2.进制
	二进制: 0b0011
	八进制: 0123
	十六进制: 0x100
	十进制: 100

	任意进制转换成十进制:
		系数*基数的权次幂

		系数:每一位上的数
		基数:几进制,基数就是几
		权:从右边开始,从0开始编号

	十进制转换成任意进制:
		除基倒取余数

---------------------------------------------------------------
3.原码反码补码:

	原码
	  |--符号位不变,其他各位取反(0变成1,1变成0)
	  |
	反码
	  |--加一
	  |
	补码

	正数: 它的原码反码补码都是一样的
	负数: 原码-->反码-->补码

---------------------------------------------------------------

4.变量定义的格式:
	数据类型 变量名=变量值;

5.数据类型:
	①引用数据类型
	②基本数据类型
		四类八种:
			整数型:byte(-128~127) short int long
			浮点型:float double
			字符型:char: 'a'=97  'A'=65  '0'=48
			布尔型:boolean  true/false

6. 整数默认是int类型
   小数默认是double类型

7.使用变量的注意事项:
	1.在同一个作用域之内,不能定义相同名字的变量
	2.在使用变量前必须要赋值.
	3.一条语句可以定义多个变量
	4.一条语句最好只声明一个变量就好了!


8.数据类型的转换:
	1.隐式转换:
		两个不相同数据类型的变量进行运算时, 会把小的数据类型提升成大的数据类型,再进行运算.
		把小的数据类型的值存储到大的数据类型的变量中!

		byte b=10;
		int x=b;

	2.强制类型转换:
		把大的数据类型存储到小的数据类型的变量中!

		(数据类型)值;

		int x=10;

		byte b = (byte)x;

	3.注意事项:
		1.byte short char 这三个类型的变量在进行运算的时候,会自动类型提升到int类型
		
		2.常量优化机制:
			byte b=3+4; 编译器在编译这句代码的时候它可以知道两个常量相加的值就是7,
			所以,它在编译的时候就把这一步运算提前做完, 把结果编译成字节码,内容就是
			byte b=7; 这样,程序在运行的时候就不需要再做相加的运算这一步了,可以提高程序的效率!


9.float类型取值范围为什么比long类型的要大?
	因为底层的存储方式不同!

10.字符和字符串进行运算时:
		1.每一个字符都对应一个ASCII码值.
		如果直接输出,那就是字符
		如果进行运算,就是使用对应的码值

		2.字符串与任意类型进行相加,都会产生一个新的字符串!


11.字符类型:
	1.字符类型的变量的赋值方式:
		1.可以赋值单引号括起来的字符: 'a'
		2.可以是字符对应的码值: 97

		但是,推荐使用第一种方式赋值!

	2.字符类型是可以存储中文的!字符类型是占了两个字节的,中文也是两个字节的!


	

12.运算符:
	1.算术运算符:	
		+ - * /  %
		/:除法运算, 两个整数相除,是得不到小数的,想得到小数, 可以把其中一个变成小数再相除!

		%: 还是做除法运算,但是取的是余数!

		++: 对变量自身加一
		--: 对变量自身减一

		++/-- 在变量的左边,先对变量进行自增/自减,然后再把自增/自减之后的值进行其他运算

		++/-- 在变量的右边,,先对变量进行自增/自减,然后再把自增/自减之前的值进行其他运算

		++/--是一个特殊的运算符,它们都具有一个特别的功能,就是隐含着强制类型转换的功能!

	2.赋值运算符:
		=,+=,-=,*=,/=,%=

		左边必须是变量
		除了=运算符,其他赋值运算符都隐含着强制转换的功能!

	3.关系运算符:
		>  >=  <   <=  ==  != 
		①关系运算符运算的结果都是boolean类型的
		②比较相等用==, 不要用=
1.运算符:
	1.逻辑运算符:
		&:遇false则false
		|:遇true则true
		^:相同为false,不同为true
		!:取反.  

		&&与&的区别,||与|的区别:
			①结果是相同
			②&&它的左边如果是false,就不会执行右边
			③||它的左边如果是true, 就不会执行右边

		逻辑运算符两边必须是boolean类型的值.
		


	2.位运算符:运算二进制的符号(了解)
		&:有0则0
		|:有1则1
		^:相同为0,不同为1
		~:按位取反
		<<: 向左移动一位,右边补0
		>>: 向右移动一位, 最高位是什么就补什么
		>>>:向右移动一位, 不管最高位是什么都补0

		一个数异或另一个数两次,结果还是这个数!


	3.三元运算符:
		格式:
			关系表达式?表达式1:表达式2

		执行流程:
			先判断关系表达式的结果是什么,如果是true,返回表达式1的结果,否则返回表达式2的结果
	
		注意事项:
			①关系表达式运算完的结果必须是boolean类型
			②表达式1和表达式2不能是输出语句.它们执行完后必须要有结果
			③三元运算符的结果必须要有一个变量接收它的结果!
		


2.键盘录入:
	步骤:
		①导包: 在class的上面写:import java.util.Scanner;

		②创建Scanner对象: Scanner sc = new Scanner(System.in);

		③通过Scanner对象从键盘获取整数数据:
			int x = sc.nextInt();




3.流程控制语句:
	1.分类:
		①顺序结构
		②选择结构
		③循环结构
	
	2.选择结构:
		1.if语句
			1.格式:
				① if(条件){
					//执行的内容;
				  }

				  如果(条件成立){ 执行大括号里面的内容 }

				② if(条件){
					 条件成立的时候执行的内容;
				  }else{
					 条件不成立的时候执行的内容;
				  }

				  如果(条件成立){
					执行这里的语句
				  }否则{
					执行这里的语句
				  }
				  
				 ③if(条件1){
					 条件成立的时候执行的内容;
				  }else if(条件2){
					执行语句;
				  }else if(条件3){
					执行语句;
				  }else if(条件4){
					执行语句;
				  }...
				  else{
					 条件不成立的时候执行的内容;
				  }
				 
		
			2.注意事项:
				1.条件表达式必须是boolean类型的.
				2.大括号不要省略
				3.有分号就不要有左大括号, 有左大括号就不要有分号!
				4.三元运算符的内容可以改写成if的第二种格式,但是if的第二种格式不一定可以改写成三元运算符.(只有是赋值的情况才可以改成三元运算符!)



		2.switch语句
			1.格式:
				switch(表达式){
					case 值1:
						执行语句;
						break;
					case 值2:
						执行语句;
						break;
					....
					default:
						执行语句;
						break;
				}

				表达式:	
					JDK1.5以前: byte short char int
					JDK1.5: 枚举
					JDK1.7: String

			2.注意事项:
				1.case后面跟的必须是常量
				2.default语句可以省略,但是不要省略
				3.break也是可以省略的, 但是不要省略
				4.default可以写在任意顺序位置, 但是一般写在最后
				5.switch语句要么是遇到break结束,要么遇到右大括号就结束!

	3.if语句和switch语句的区别:	
		if语句适合判断范围
		switch语句适合判断固定值(而且必须是支持的数据类型!)^的特点:一个数据被统一数据异或两次 该数本身不变
面试时可能会要用到此特性   (两数交换时不用第三方变量)
代码最重要的是阅读性(越简单易懂最好)   高效性第二1.流程控制语句:循环语句
	1.分类:
		1.for循环
		2.while循环
		3.do...while循环(了解)

	2.for循环:
		格式:
			for(①初始化表达式;②条件表达式;④循环后的操作表达式){
				③循环体;
			}

			注意事项:
				1.初始化表达式只执行一次!
				2.条件表达式结果必须是boolean类型
				3.在循环中定义的变量,只在循环中有效!

	3.while循环:
		格式:
			初始化表达式;
			while(条件表达式){
				循环体;
				循环后的操作表达式;
			}

	4.do...while循环:
		格式:
			初始化表达式;
			do{
				循环体;
				循环后的操作表达式;
			}while(条件表达式);

	5.三种循环的区别:
		do...while循环至少会执行一次循环体.其他两个循环都是先判断条件,再决定是否执行循环体,可能会一次都不执行!

		for循环中的初始化表达式中定义的变量,只在循环中有效,循环结束后就会被释放掉
		while循环中初始化表达式中定义的变量,一直有效,可以在循环结束后继续使用!

	6.死循环(无限循环):
		for(;;){...}

		while(true){...}


	7.转义字符:
		\t: 制表符
		\r: 回车
		\n: 换行

	8.控制跳转的语句:
		break:
			①它可以使用在switch语句和循环语句中.
			②作用是结束当前循环.

		continue:
			只能用在循环中
			作用是终止本次循环,继续下次的循环

		return:
			① 返回方法运行的结果
			② 结束方法.

	9.标号:(了解)
		可以在内层循环控制外层循环结束.
		

2.方法(函数)
	1.为什么要有方法?
		方法的作用是提高代码的复用性!
	
	2.方法定义的格式:
		修饰符 返回值类型 方法名(数据类型 变量名1,数据类型 变量名2){
			方法体;
			return 结果;
		}

		public static int add(int a,int b){
			int sum = a+b;//方法体
			return sum;
		}

		形式参数:定义方法时在方法上声明的变量
		实际参数:调用该方法时传入的数据

	3.注意事项:
		1.方法的调用:	
			①有返回值的方法
				单独调用(没有意义): add(10,20);
				输出调用: System.out.println(add(10,20));
				赋值调用: int x = add(10,20);

			②没有返回值的方法
				只能单独调用!

		2.其他注意事项:
			①方法与方法之间是平级关系,不能嵌套
			②方法没有调用不会执行
			③参数与参数之间用逗号隔开
			④调用方法时,传入参数不需要写类型
			⑤如果方法有写明确的返回值类型,必须由return带回结果

		3.方法的定义:
			①明确返回值类型
			②明确参数列表
			


		4.方法重载:
			前提:在同一个类中!
			方法名相同,参数列表不同,与返回值类型无关!


1.面向对象
	1.思想上的特点:
		①更符合人们思考的习惯
		②将复杂的事情简单化
		③把程序员从执行者变成了指挥者

	2.特征:
		①封装
		②继承
		③多态

	3.类的定义:
		属性-->成员变量
		行为-->成员方法
		

	4.类的使用:
		①创建对象:
			类名 对象名 = new 类名();

		②使用成员变量:
			对象名.变量名

		③使用成员方法:
			对象名.方法名(...)

	5.成员变量与局部变量的区别:
		1.定义的位置不同
			成员变量:定义在类中方法外的
			局部变量:定义在方法中或者方法声明上

		2.在内存中的位置不同
			成员变量:在堆内存中
			局部变量:在栈内存中

		3.生命周期不同
			成员变量:随着对象的创建而存在,随着对象的消失而消失
			局部变量:随着方法的调用而存在,随着方法调用完毕而消失

		4.初始化不同
			成员变量:有默认的初始化值
			局部变量:没有默认初始化值,使用前必须要手动赋值.

	
	6.变量使用时查找的顺序:
		就近原则:
		局部位置(局部变量)-->成员位置(成员变量)

	7.匿名对象:
		1.目的: 简化代码
		2.作用:
			①当作方法的参数传递
			②只调用该对象中的方法一次!
	

2.封装
	1.概述:
		隐藏实现细节,仅对外提供公共的访问方式

	2.好处:
		①隐藏实现细节,仅对外提供公共的访问方式
		②提高代码的复用性
		③提高安全性

	3.private关键字:	
		1.特点:
			是一个权限修饰符,被修饰的内容只能在本类中访问

		2.可以修饰:
			成员变量, 成员方法.

	4.this关键字:	
		1.代表的是调用该方法的那个对象

		2.作用: 用于区分局部变量与成员变量重名的情况, this可以指定访问的是成员变量

	5.现阶段定义类时,成员变量必须要定义成私有的,然后每个成员变量都要有对应的set和get方法!

	6.set/get方法的规律:
		set方法不需要返回值, get方法必须要用返回值
		set方法必须要有参数, get方法不需要参数
		setXxx,getXxx --> Xxx是成员变量的名字,首字母大写

1.封装(构造方法)
	1.什么样的方法才能叫构造方法?
		①方法名与类名相同
		②没有返回值类型
	
	2.构造方法的作用:	
		初始化成员变量

	3.构造方法特点:
		①在创建对象的时候被调用, 不能使用对象调用
		②没有返回值类型,也不能在方法中写return返回具体的值,void也没有: 不能写: return 5;
		③可以在构造方法中写return语句,但是作用是结束方法. return;

	4.方法重载:	
		在同一个类中,方法名相同,参数列表不同,与返回值无关
		构造方法可以满足以上所有条件,所以构造方法也是可以重载的!

	5.注意事项:
		①如果没有定义构造方法, 系统会默认提供一个空参的构造方法
		②如果已经定义构造方法, 系统不会再提供默认的构造方法了!
		③如果有定义有参构造,建议手动给出空参构造!

	6.成员变量的两种赋值方式的区别:
		构造方法:只是给成员变量进行初始化,只能调用一次!
		set方法: 可以修改成员变量的值,可以多次调用.比较灵活!

	7.标准类:
		①成员变量私有化:private
		②空参构造和有参构造
		③每个成员变量有对应的set/get方法

	8.对象的创建步骤:
		①把字节码文件加载进方法区
		②在主方法中声明一个引用
		③在堆内存中创建一个对象
		④成员变量进行默认初始化
		⑤成员变量进行显式初始化
		⑥构造方法初始化成员变量
		⑦把对象的地址值赋值给主方法中的引用!


2.static(静态)
	1.作用
		让所有对象共享被修饰的内容.
		静态修饰的内容都是存放在方法区中的静态区

	2.特点:
		①随着类的加载而加载
		②优先于对象而存在
		③被所有对象共享
		④可以通过类名调用: 类名.变量名   类名.方法名()
			也可以通过对象调用,但是推荐使用类名调用

	3.静态的注意事项:	
		①静态中是不能有this关键字的
		②静态只能访问静态的成员!

	4.静态变量与成员变量的区别:
		1.所属不同
			静态变量:属于类的,也叫类变量
			成员变量:属于对象,也叫对象变量(实例变量)

		2.在内存中的位置不同
			静态变量:在方法区中的静态区
			成员变量:堆内存中

		3.生命周期不同
			静态变量:随着类的加载而加载,随着类的消失而消失
			成员变量:随着对象的创建而存在,随着对象的消失而消失

		4.调用方式不同
			静态变量:可以使用类名调用,也可以通过对象调用
			成员变量:只能用对象调用

		5.工具类:	
			只提供功能的类

			把所有方法都定义成静态的. 构造方法私有化!(不让人创建对象)

	

3.文档注释
	1.Math类: 与数学相关的类

	2.Math.random(): 获取0.0~1.0之间的随机数.

	3.如何获取一个1~100之间的随机数:
		Math.random(): 0.0~0.9999999999999999999999999
		Math.random()*100: 0.0~99.999999999999999999999
		(int)(Math.random()*100): 0~99
		(int)(Math.random()*100)+1: 1~100
1.代码块(了解)
	1.分类:	
		①局部代码块
		②构造代码块
		③静态代码块
		④同步代码块(多线程讲)

	2.局部代码块:
		在方法中的代码块就是局部代码块
		作用: 限定变量的生命周期
		执行时间:方法调用时执行

	3.构造代码块
		定义在类中方法外的,没有任何修饰符
		作用: 把所有构造方法中相同的代码放到构造代码块中,提高代码复用性
		执行时间: 创建对象时执行,优先于构造方法执行

		每创建一个对象就调用一次!

	4.静态代码块
		定义在类中方法外,有static修饰符
		作用: 加载资源
		执行时间: 类加载的时候执行
			①跟主方法在同一个类中,优先于主方法执行
			②不跟主方法在同一个类,不会优先于主方法执行!

		静态代码块只执行一次!



2.继承
	1.让类与类之间产生关系,通过extends关键字

	2.特点:
		子类可以使用父类中的非私有的属性和方法

	3.继承的好处和弊端:	
		好处:
			1.提高代码的复用性
			2.提高代码的维护性
			3.让类与类之间产生了关系,是多态的前提

		弊端:
			耦合性增强(类与类之间的关系太紧密了)

	4.继承的特点:	
		在java中,类只能单继承,不能多继承,但是可以多层(多重)继承

	5.注意事项:	
		1.子类只能继承父类中的非私有内容
		2.子类是不能继承父类中的构造方法,但是可以访问父类的构造方法
		3.不要为了继承而继承

	6.什么时候继承?
		当类A是类B的一种的时候就可以使用继承: class A extends B{....}

	7.继承中成员变量的关系:	
		就近原则:
			变量在使用过程中,先在方法中找,找不到就到本类中的成员位置找,还找不到就到父类中成员位置找

	8.this和super的区别:	
		1.this可以调用本类中的成员变量,当本类中没有该变量时,可以调用父类中的成员变量
			super只能调用父类中的成员变量.

		2.this调用的是本类的构造方法
			super调用的是父类的构造方法.

		3.this可以调用本类中的方法,当本类中没有该方法时,可以调用父类中的方法
			super只能调用父类中的方法

	9.子类默认访问父类中的空参构造.
		为什么?
			因为子类继承了父类中的成员变量,如果想要使用需要先对它们进行初始化.所以,子类需要先调用父类的构造方法,对它们进行初始化.

		
	10.继承中构造方法的注意事项:
		this和super在调用构造方法时,必须是在构造方法的第一句!
		如果父类中没有空参构造,可以通过super来指定访问父类中的哪个有参构造,把参数传递给父类!

	
	11.在继承中成员方法的特点:
		子类在调用方法时,如果子类中没有该方法,可以调用父类中的方法.
		如果子类中有和父类中相同的方法时, 调用的是子类的方法.
		
	12.方法重写:
		前提: 要有继承关系
		子类中存在一个与父类方法名相同,参数列表相同,返回值类型相同的方法,就是方法的重写!

		作用: 对父类中的方法进行增强!

	13.方法重写的注意事项:	
		1.子类只能重写父类中非私有的方法,不能重写私有的方法
		2.子类在重写父类方法时,权限必须大于等于父类中方法的权限
		3.静态方法只能重写静态方法!


3.final关键字
	1.final可以修饰:
		类:不能被继承
		方法:不能被重写
		变量:变成常量, 只能赋值一次!
	
	2.final修饰基本数据类型变量时,不能重新赋值
	final修饰引用数据类型变量时,该变量不能重新指向新的对象,但是它的属性是可以改变的

	3.final修饰的成员变量初始化时机:
		①显示初始化
		②在构造方法中进行初始化
		③还可以在构造代码块中完成初始化
	1.多态: 多种形态
	1.多态的前提:
		1.继承
		2.要有方法重写(不是必须条件,但是没有方法重写的多态是没有意义的!)
		3.要有父类引用指向子类的对象

	2.多态访问成员变量的特点:
		编译看左边(父类),运行也是看左边;

	3.多态访问非静态成员方法的特点:
		编译看左边(父类),运行看右边(子类)

	4.多态访问静态成员方法的特点:
		编译看左边(父类),运行看左边(父类)

	5.多态中访问成员的特点(记住这个即可!)
		只有非静态方法是编译看左边,运行看右边的.
		其他成员都是编译和运行都是看左边的!

	6.向上转型和向下转型:
		向上转型: 父类引用指向子类对象
			 Fu f=new Zi();

		向下转型: 把向上转型的引用再强制转换成子类类型
			Zi z = (Zi)f;

	7.多态的好处和弊端:
		好处:
			1.提高代码的维护性(继承)
			2.提高代码的扩展性(多态)

		弊端:
			不能使用子类特有的属性和行为
	


2.抽象
	1.使用abstract关键字修饰的类就是抽象类

	2.抽象类的特点:	
		1.抽象类必须使用abstract关键字修饰
		2.抽象类中可以有抽象方法,也可以没有
		3.抽象类是不能创建对象
		4.抽象类的子类: 要么是抽象类,要么重写父类中的所有抽象方法

	3.抽象方法:
		被abstract关键字修饰,并且没有方法体的方法!

	
	4.抽象类的成员:
		成员变量: 可以是变量,也可以是常量
		成员方法: 可以是抽象方法,也可以是普通方法
		构造方法: 有构造方法, 给子类初始化用!

		总结: 抽象类跟普通类的区别,就是抽象类比普通类多了一个抽象方法!

	
	5.抽象类的作用:
		1.强制让子类一定要重写某个方法
		2.不让别人创建对象

	6.abstract关键字不能与什么关键字共存:	
		static:	静态修饰的内容可以通过类名调用.abstract修饰的方法没有方法体的,调用了也没有意义.
		final: final修饰的方法不能被重写,abstract修饰的方法要求子类必须重写
		private:prvate修饰的方法不能被继承,abstract修饰的方法必须要被子类重写!


3.接口
	1.接口就是规则

	2.接口的特点:
		1.定义接口用: interface
		2.实现接口用: implements
		3.接口不可以创建对象
		4.接口的子类: 要么是抽象类,要么重写所有的抽象方法

	3.接口中的成员:
		成员变量: 只有常量,没有变量,因为接口中的成员变量都有默认的修饰符: public static final
		成员方法: 只有抽象方法, 因为接口中的成员方法有默认修饰符: public abstract
		构造方法: 没有构造方法

	4.类与类,类与接口的关系:
		类与类:继承关系,只能单继承,不能多继承,不过可以多层继承
		类与接口: 实现关系,可以单实现,也可以多实现
		接口与接口: 继承关系,可以单继承,也可以多继承!


	5.抽象类与接口的区别:	
		1.成员的区别:
			抽象类:普通类有的内容它都可以有,还可以有抽象方法
			接口: 只能有常量 和 抽象方法

		2.关系的区别:
			抽象类与类是继承关系
			接口与类是实现关系

		3.设计理念的区别:
			抽象类体现的是: is a 关系,什么是什么的一种
			接口体现的是: like a 关系1.包
	1.包其实就是文件夹

	2.作用:
		把字节码文件进行分类管理

	3.定义包名:
		package 包名;

	4.注意事项:
		1.package语句必须是第一条可执行语句
		2.package语句在一个java文件中只能写一个
		3.如果没有定义包名,默认无包名

	5.带包的类如何编译和运行:	
		编译: javac -d 字节码存放路径 源文件名
				javac -d . Xxx.java

		运行: java 包名.类名
				java com.itheima.Person

		全类名: 包名+类名: com.itheima.Person

	6.不同包下的类如何访问:
		类必须要定义成public的. public修饰的类名必须要跟文件名相同

		使用全类名进行访问:
			new 包名.类名();

	7.导包:
		import 包名.类名;

		顺序:
			package ---> import ---> class



2.权限修饰符
	public: 给所有的类使用
	protected:给子类使用
	默认权限:给同一个包下的类使用
	private:只想给自己用

	public > protected > 默认 > private

	常见的修饰符:
		static 
		final 
		abstract


3.内部类
	1.定义在类的内部的类就是内部类, 定义在类中方法外

	2.内部类的访问特点:
		内部可以直接访问外部类的所有成员,包括私有的
		外部类想要访问内部类中的内容, 需要创建内部类的对象

	3.内部类需要掌握的内容:
		①如何定义内部类
		②如何在外部类中创建内部类对象.

	
	4.局部内部类在访问局部变量:
		局部变量必须使用final修饰!

4.匿名内部类
	1.前提:
		必须要有一个父类或者一个接口

	2.格式:(new 出来实际上是该类或该接口的子类的对象)
		new 类名或者接口名(){
			重写父类或者接口中的方法;
		}.方法名();

	3.本质:
		就是继承了该类或者实现了该接口的子类的对象!

	4.匿名内部类只适合重写并调用一个方法的情况!

	5.匿名内部类的应用:
		1.作为方法的参数传递
		2.只调用方法一次!

1.Scanner(了解)
	常用方法:
		hasNextXxx(): hasNextInt   hasNextDouble  hasNextLine ...
		nextXxx(): nextInt  nextDouble  nextLine ....

	BUG:
		先录入一个整数,再录入一个字符串,就会出现BUG

	解决方案:	
		1.创建两个Scanner对象,但是比较浪费空间
		2.所有数据使用字符串接收, 再转换成对应的数据类型!


2.String类(重点)
	1.字符串是一个不可变的字符序列

	2.字符串一旦初始化就不可以改变!


	3.构造方法:
		String()
		String(byte[])
		String(byte[],开始位置,转换个数)
		String(char[])
		String(char[],开始位置,转换个数)
		String(String)

	4.String中的常用方法
		1.判断功能
			equals(): 判断两个字符串是否相同(区分大小写的)
			equalsIgnoreCase(): 判断两个字符串是否相同(不区分大小写的)
			contains(): 判断字符串中是否包含指定的字符串
			startsWith(): 判断字符串是否以指定的字符串开头
			endsWith(): 判断字符串是否以指定的内容结尾
			isEmpty(): 判断字符串中的内容是否为空!
		
		2.获取的功能:	
			length(): 获取字符串中的长度
			charAt(index): 根据索引获取指定位置的字符
			indexOf(int ch): 根据字符查找第一次出现的索引
			indexOf(int ch,int startIndex): 从指定位置开始查找字符第一次出现的索引
			indexOf(String): 查找字符串第一次出现的位置
			indexOf(String,startIndex): 从指定位置开始查找字符串第一次出现的位置
			lastIndexOf(int ch): 从后面开始查找字符第一次出现的位置
			...
			substring(startIndex): 从指定位置开始截取字符串,默认到末尾
			substring(startIndex,endIndex): 从指定位置开始截取字符串,到指定位置结束(不包含结束位置)

		3.转换功能:
			getBytes(): 把字符串转换成字节数组
			toCharArray(): 把字符串转换成字符数组
			valueOf(Object): 可以把任意数据转换成字符串
			
			toUpperCase(): 把字符串转换成大写的
			toLowerCase(): 把字符串转换成小写的
			concat(): 两个字符串进行拼接.

		4.其他功能:
			replace(char a,char b): 替换字符串中的指定字符
			replace(String a,String b): 替换字符串中的指定字符串
			trim(): 去掉字符串前后的空格
			compareTo(): 比较两个字符串的大小,区分大小写
			compareToIgnoreCase(): 比较两个字符串的大小,不区分大小写



3.学习的流程:
	有一个什么样的类(String-->字符串)---->这个类的常用构造方法有什么(如何创建这个类的对象)--->这个类里面的常用方法(一一演示这些方法的作用,以后需要用到时就会想起它)1.StringBuffer
	1.是一个可变的字符序列.(字符串的缓冲区)

	2.是从JDK1.0的时候出现的,是线程安全的!

	3.构造方法:
		StringBuffer(): 这个构造方法的初始容量是:16个字符
		StringBuffer(int 容量): 在创建字符串缓冲区的时候指定它的初始容量(了解)
		StringBuffer(String): 在创建字符串缓冲区的时候,添加初始内容


	4.常用方法:
		1.添加方法:
			append(Object): 向字符串缓冲区追加内容
			insert(int,Object): 在指定位置插入内容

		2.删除方法:
			deleteCharAt(index): 删除指定位置的字符
			delete(startIndex,endIndex): 删除从指定位置开始到指定位置结束的字符串,不包含结束位置!

			delete(0,sb.length());//可以清空缓冲区

		3.替换和反转的方法:
			replace(开始位置,结束位置,替换的内容): 替换缓冲区中的字符串
			reverse(): 把缓冲区中的字符串反转

		4.截取字符串:
			substring(index) 
			substring(开始位置,结束位置)

		5.String和StringBuffer互相转换:
			String--->StringBuffer:
				①构造方法
				②append方法

			StringBuffer--->String
				①构造方法
				②toString方法
				③substring方法

		
	5.String和StringBuffer,StringBuilder的区别:
		String是一个不可变的字符序列
		StringBuffer和StringBuilder都是可变的字符序列

		StringBuffer是线程安全的,效率低, 从JDK1.0出现的
		StringBuilder是线程不安全的,效率高,从JDK1.5出现的!

	
	6.String作为方法的参数传递时, 在方法中对它做了修改, 不会影响到原来的变量的值.
		因为String的值一旦初始化就不可以改变!


2.数组高级应用
	1.冒泡排序
		
		for(int i=0;i<arr.length-1;i++){
			for(int j=0;j<arr.length-1-i;j++){
				if(arr[j]>arr[j+1]){
					int temp = arr[j];
					arr[j]=arr[j+1];
					arr[j+1]=temp;
				}
			}
		}


	2.选择排序
		
		for(int i=0;i<arr.length-1;i++){
			for(int j = i+1;j<arr.length;j++){
				if(arr[i]>arr[j]){
					int temp = arr[i];
					arr[i]=arr[j];
					arr[j]=temp;
				}
			}
		}


	3.二分查找
		


	4.工具类
		toString(): 把数组转成字符串
		sort(): 对数组进行排序
		binarySearch(): 二分查找

3.包装类
	1.包装类就是基本数据类型对应的引用类型

	2.包装类的作用:
		可以更方便地操作基本数据类型

	3.基本类型对应的包装类:
		byte			Byte
		short			Short	
		char	--->	Character
		int		--->	Integer
		long			Long
		float			Float
		double			Double
		boolean			Boolean

	4.Integer构造方法:
		Integer(int): 把一个基本类型的值封装成引用数据类型
		Integer(String): 把一个数字字符串转换成包装类对象

	5.基本类型int与String之间的转换:
		int--->String :
			10+"";

		String-->int
			包装类的parseInt方法
			int x = Integer.parseInt("100");

		注意事项:
			八种包装类中, 有七种是有parseXxx方法的,只有Character这个包装类没有!

	6.自动装箱和拆箱:
		自动装箱:
			把基本数据类型转换成包装类的对象:
				Integer i = 100;// Integer i = new Integer(100);

		自动拆箱:
			把包装类的对象转换成基本数据类型:
				int z = i+100;  // int z = i.intValue() + 100;

	7.面试题:
		通过自动装箱获取到的对象,如果是在byte的取值范围内的, 不会创建对象, 而是从常量池中获取该对象. 
	


1.正则表达式
	1.正确的规则

	2.常用内容:
		1.字符类:	
			[abc]: 只能是其中一个
			[a-zA-Z]: 是这个范围中的一个
			[^abc]: 不能是其中的一个

		2.预定义字符:
			. : 代表任意单个字符
			\d: 代表数字字符[0-9]
			\D: 代表非数字字符
			\s: 代表空白字符: \t \r \n 
			\S: 代表非空白字符
			\w: 代表单词字符: [a-zA-Z_0-9]
			\W: 代表非单词字符

			在字符串中两个\代表一个,因为\在字符串中有转义的效果!


		3.数量词:
			? : 代表一次或者没有
			* : 代表0到多次
			+ : 代表一次或者多次
			{n}:代表恰好出现n次
			{n,}: 代表至少出现n次
			{n,m}:代表出现n到m次

	4.正则的应用:
		
		s.matches(regex) : 完全匹配

		1.切割:
			String类中的split方法:
				split中的参数可以是正则表达式

		2.替换:
			分组:在正则中,小括号用于分组,有几个左小括号就有几组,第几个左括号就是第几组!
				(()(()))

				第0组,指的是整个正则表达式

			replaceAll(regex,"内容") : 内容部分可以通过 $组号 来引用第一个参数中的分组的内容

		3.java中支持正则的类:
			Pattern p = Pattern.compile("正则"); // 把正则表达式编译成正则对象
			Matcher m = p.matcher("需要匹配的字符串"); //用正则来匹配字符串,得到一个匹配器对象
			
			m.find(): 查找字符串中是否有匹配正则的内容,如果有,返回true, 每调用一次,指针向后移动一次
			m.group(): 获取查找到的匹配正则的字符串

		



2.其他常用API
	1.Math类:
		abs(): 获取绝对值
		ceil(): 向上取整,是一个小数
		floor(): 向下取整,也是一个小数
		max(x,y): 取最大值
		round(double): 四舍五入
		pow(x,y): 求x的y次方
		sqrt(x): 对x进行开平方
		random(): 获取随机数

	2.Random类:
		构造方法:
			Random(): 默认使用系统的纳秒时间作为种子
			Random(long): 使用指定的种子创建对象
			
		常用方法:
			nextInt(): 随机生成int范围的整数
			nextInt(n): 随机生成在0~n之间整数,不包含n


	3.System类:
		gc(): 呼唤垃圾回收器(了解)
		exit(int):退出虚拟机,参数0代表正常终止,非0代表异常终止
		currentTimeMillis():得到当前系统时间的毫秒值. 这个毫秒值是从1970年1月1日 0时0分0秒开始到现在的毫秒值.

		
	4.BigInteger类: 大整数类
		用于计算远远超过int范围的整数
		构造方法:	
			BigInteger(String): 把整数字符串转换成BigInteger对象

		常用方法:
			add(BigInteger): 加法
			subtract(BigInteger): 减法
			multiply(BigInteger): 乘法
			divide(BigInteger): 除法
			divideAndRemainder(BigInteger): 除法返回的是商和余数,返回的是一个BigInteger数组
		
	5.BigDecimal类:
		能够计算精度更高的小数

	6.Date类:
		构造方法:
		Date(): 使用系统当前时间创建的日期对象
		Date(long): 使用指定的毫秒值作为时间创建的日期对象

		常用方法:
			getTime(): 获取日期对象中的毫秒值
			setTime(long): 设置日期对象中的毫秒值!

		
	7.SimpleDateFormat类:
		构造方法:
			SimpleDateFormat("日期格式"): 按照指定的日期格式创建对象
				yyyy: 年
				MM: 月
				dd: 日
				HH: 时
				mm: 分
				ss: 秒
				
		常用方法:
			format(Date): 把日期对象转换成字符串
			parse(String): 把日期字符串转换成日期对象

	8. Calendar类:日历类
		1.如何得到对象:
			Calendar c = Calendar.getInstance();

		2.常用方法:
			get(int): 根据传入的参数返回不同的值!
			add(字段,增加或者减少的值): 可以对指定的字段增加或者减少
			set(): 设置指定时间



	1.集合体系
	1.引用类型数组:
		数据类型[] 数组名 = new 数据类型[长度];

		一个类就是一个类型


	2.集合的由来:
		1.集合与数组的区别:
			1.存储的数据类型
				数组可以存储基本数据类型,也可以存储引用数据类型
				集合只能存储引用数据类型

			2.长度
				数组的长度是固定的
				集合的长度是可变的!

		2.什么时候使用哪个?
			当存储的元素是固定个数的时候使用数组
			当存储的元素个数不确定时使用集合!


		3.集合体系:
			Collection:接口
				|--List:(接口): 有序, 有索引, 可以存储重复元素
					|--ArrayList
					|--LinkedList
					|--Vector
				|--Set(接口): 无序,无索引, 不可以存储重复元素
					|--HashSet
					|--TreeSet

			有序:
				存进去的顺序和取出来的顺序一致

		
		4.集合中的常用方法:
			boolean add(Object obj): 把元素存储到集合中, 返回是否存储成功.  List集合中只会返回true  Set如果是重复的就返回False
			void remove(Object): 把集合中的指定元素删除
			void clear(): 清空集合
			boolean contains(Object): 判断集合中是否包含指定的元素
			boolean isEmpty(): 判断集合是否为空
			int size(): 获取集合的长度

		5.集合转成数组:
			<T> T[] toArray(): 把集合转成Object数组
				注意: 这个方法里面创建的就是Object数组, 不可以强转成其他类型的数组!

		6.Collection中带All的方法:
			addAll(Collection): c1.addAll(c2):把c2集合中的所有元素存储到c1集合中
			removeAll(Collection): c1.removeAll(c2): 把c1集合中与c2集合相同的元素删除
			containsAll(Collection): c1.containsAll(c2): 判断c1集合中是否包含c2集合中的所有元素
			retainAll(Collection): c1.retainAll(c2): 取两个集合的交集内容(了解)

		7.集合的第二种遍历方式: 迭代器
				//获取迭代器对象:
				Iterator it = 集合对象.iterator();

				判断集合中是否有元素:
				it.hasNext()

				//获取元素
				Object obj = it.next();

		8.List集合的特有方法:
			add(index,Object):把元素添加到指定的位置
			remove(index): 根据索引删除元素
			get(index): 根据索引获取元素
			set(index,value): 把指定位置的元素修改成value

		9.并发修改异常:
			1.发生的原因:
				在使用迭代器进行遍历集合,然后使用集合来增删元素!

			2.解决方案:
				使用List集合特有的迭代器进行遍历, 然后使用这个迭代器的方法来进行增删元素.

		10.List集合的特有迭代器: ListIterator
			add(Object): 添加元素
			remove():删除遍历到的元素
			hasNext(): 是否有下一个元素
			next(): 获取下一个元素
			hasPrevious(): 是否有上一个元素
			previous(): 获取上一个元素

			除了可以正向遍历,还可以反向遍历(做反向遍历前需要先做正向遍历)
			
		11.数据结构:	
			1.数组结构:
				查找修改快,增删慢

			2.链表结构:	
				增删快,查找修改慢
		
		12.List的三个子类:
			ArrayList:
				底层是数组结构,查找修改快,增删慢. 线程不安全,效率高

			LinkedList:
				底层是链表结构,增删快,查找修改慢, 线程不安全,效率高

			Vector:
				底层是数组结构,查询增删都很慢!线程是安全的,效率低!

			什么时候使用哪个集合?
				查询修改多,用ArrayList
				增删多, 使用LinkedList

				如果都很多,用ArrayList

1.ArrayList集合去除重复元素
	结论:
		ArrayList集合中的contains和remove方法底层是依赖存储的对象中的equals方法, 如果需要用到集合的判断和删除方法
		那么存储的对象就一定要重写equals方法!

2.LinkedList集合
	addFirst(Object)
	addLast(Object)
	removeFirst()
	removeLast()
	getFirst()
	getLast()

3.数据结构:	
	1.栈:
		先进后出
		
	2.队列结构:
		先进先出

4.泛型:
	1.泛型的好处:
		1.提高安全性(把运行时期的错误提前到编译时期)
		2.省去强转的麻烦

	2.注意事项:
		1.前后的泛型必须一致
		2.不要把泛型定义成Object,没有意义
		3.JDK1.7的时候,后面的泛型可以写成<> , 菱形泛型

-----------------------------以下为了解的内容----------------------------
	3.泛型类:(了解)
		在定义类的时候, 在类名后面加上泛型!

	4.泛型方法:(了解)
		非静态方法:
			可以使用类上声明的泛型,也可以自己声明一个泛型
		
		静态方法:
			必须自己声明一个泛型,不能使用类上定义的泛型

	5.泛型接口
		在定义接口的时候声明一个泛型
			1.在子类实现接口时可以指定接口的泛型
			2.在子类创建对象时可以指定接口的泛型

	6.泛型通配符:
		? : 任意类型的泛型
		? extends E : 向下限定, 只能是E或者它的子类
		? super E : 向上限定, 只能是E或者它的父类

---------------------------------------------------------------------------

	JDK1.5新特性:
		
	1.增强for
		格式:
			for(数据类型 变量名:数组或者集合){
				
			}

		作用: 只能用来遍历数组或者集合

		好处: 简化遍历的操作

		底层: 是由迭代器实现

	2.三种遍历的方式:
		1.普通for循环遍历:	
			可以在遍历的时候删除元素,删除的时候要减减

		2.迭代器遍历:
			可以在遍历的时候删除

		3.增强for遍历:
			不可以在遍历的时候删除

	3.静态导入(了解)
		格式:
			import static 包名.类名.方法名;

	4.可变参数
		定义在方法的参数列表上的.

		本质: 是一个数组

		当一个方法的参数有多个时,可变参数必须是最后一个!

	5.Arrays工具类的asList()方法
		asList(): 可以把一个数组转换成集合,如果是基本数据类型的数组,转换成的集合,该数组只是集合中的一个对象!
					如果是引用数据类型的数组, 数组中的元素就是集合的元素

		
		集合转换数组的方法:
			toArray(): 把集合转成Object数组
			toArray(T[]): 把集合转换成指定类型的数组

			在转换成数组的时候,必须传入一个数组对象, 给的是什么类型的数组,转换的就是什么数组
			指定的数组长度如果小于等于集合的长度,转换的数组长度就是集合的长度
			如果指定的数组长度大于集合的长度,返回的数组长度为指定的长度

	6.集合的嵌套(了解)Set集合: 无序,无索引,不可以存储重复元素!

1.HashSet集合
	1.HashSet集合需要元素重写hashCode方法和equals方法才能保证元素的唯一性!

	2.两个不同的对象,hashCode值有可能相同,也可能不同.但是两个相同的对象,hashCode值一定相同!
	
	3.在HashSet集合存储元素时, 先调用hashCode方法,如果相同,再调用equals方法比较是否相同的对象!

	4.LinkedHashSet:
		它是HashSet的子类,在保证元素唯一性的同时,还可以有序!
		

2.TreeSet集合
	1.TreeSet集合的特点:
		可以对元素进行排序!
	
	2.如果想要使用TreeSet集合存储自定义对象,自定义的对象必须要实现Comparable接口,重写compareTo方法
		特点:
			当compareTo方法返回0时,集合中只存储一个对象
			当compareTo方法返回正数时,集合怎么存就怎么取
			当compareTo方法返回负数时,集合倒序存储

	3.TreeSet集合可以有两种排序方式:
		1.自然排序
			就是让元素自身实现Comparable接口,重写compareTo方法

		2.比较器排序
			在创建TreeSet集合时,从构造方法中传入一个比较器对象,集合中的元素就会按照比较器的方式进行排序

		3.当两种方式同时存在时, 优先使用比较器排序!
		
		4.两种方式的区别:
			自然排序代码量较少,使用比较方便, 不需要传递参数! 弊端是比较的方式比较单一
			比较器排序,代码比较复杂,在创建集合对象时还需要传递比较器的对象! 但是可以有多个不同的比较器,
			使用上比较灵活!
	

		1.Map集合
	存储的是键和值(key和value)

	Collection 存储的是单例的
	Map存储的是双列的

	HashSet底层是HashMap实现的
	TreeSet底层是TreeMap实现的

	1.Map集合的常用方法:	
		1.添加:
			put(key,value): 存储一对键值对,返回的是被覆盖的值
		
		2.删除:
			remove(key): 根据键删除元素,返回对应的值

		3.判断功能:
			containsKey(key): 判断是否包含指定的键
			containsValue(value): 判断是否包含指定的值
			isEmpty(): 判断集合是否为空
			keySet()
			entrySet()
			get(key): 根据键获取值
		
		4.获取功能:
			values(): 把Map集合中的所有的值存储到一个Collection集合中并返回!
			size(): 获取集合中的元素个数

	2.Map集合的遍历方式:
		1.通过键查找值:
			1.通过迭代器实现
				keySet()得到键的集合
				遍布这个集合,得到每一个key
				再通过get(key),得到每一个value

			2.通过增强for实现

		2.通过键值对对象获取键和值
			1.通过entrySet方法获取键值对对象的Set集合
			2.遍历这个集合,得到每一个键值对对象(Entry)
			3.通过键值对对象的getKey()得到键,getValue()得到值

	
	
	




	
2.Map集合的两个子类
	1.HashMap集合的键必须要重写hashCode方法和equals方法,才能保证键的唯一性, 值不需要保证唯一性!

	2.Map集合的所有特点都是针对键的,与值无关!

	3.LinkedHashMap:
		可以保证存取顺序一致

	4.TreeMap:
		可以对集合中的键进行排序.
		键必须要实现Comparable接口
		或者传入比较器对象,比较器对象比较的键!

	5.HashMap 和 Hashtable 的区别:
		1.是否线程安全
			Hashtable是线程安全的,效率低! JDK1.0的时候出现的
			HashMap是线程不安全的,效率高! JDK1.2出现的

		2.是否可以存储null键和null值
			HashMap可以存储null键和null值
			Hashtable不可以存储null键和null值


3.Collections类
	1.常用方法:	
		sort(List): 对集合中的元素进行排序
		binarySearch(List): 二分查找 
		max(Collection): 获取集合中的最大值
		reverse(List): 反转集合中的元素
		shuffle(List): 随机置换集合中的元素

		sort方法和max方法中的集合参数中的元素必须要实现Comparable接口!

	2.1.异常
	1.异常体系:
		Throwable
			|--Error: 错误
			|--Exception: 异常
				|--RuntimeException: 运行时异常
				|--其他异常: 编译时异常

	2.JVM默认的异常处理方式:
		在控制台转出异常的名字和发生异常的位置. 把程序停止!

	3.处理异常的方式:

		1.一次处理一个异常:

			try{
				正常的代码,这些代码可能会发生异常!
			}catch(异常的类型 变量名){
				当发生异常的时候,对异常的处理.
			}

		2.一次处理多个异常:
			try{
				正常的代码,这些代码可能会发生异常!
			}catch(异常类型1 变量名){
				针对异常类型1的处理方式
			}catch(异常类型2 变量名){
				针对异常类型2的处理方式
			}...

	4.编译时异常和运行时异常的区别:
		编译时异常: 必须要做处理,要么抛出去,要么try catch捕捉异常
		运行时异常: 可以不做处理,也可以像编译时异常一样处理

	5.Throwable中的常用方法:
		getMessage(): 获取异常的信息
		toString(): 返回的是异常的类名和异常信息
		printStackTrace(): 在控制台中打印异常的类名,信息和异常的位置

	6.throws处理异常的方式:
		当在调用一个有抛出异常的方法时,可以把这个异常向上抛出, 在方法上用 throws异常类名 就可以把异常
		抛出.
	
	7.throw和throws的区别:	
		throw使用在方法中, 用于抛出异常对象,一次只能抛出一个对象
		throws用在方法声明上,用于抛出异常类,一次可以抛出多个类,用逗号隔开!

	8.finally关键字:
		finally关键字修饰是代码块,这个代码块必须要与异常处理代码块一起使用,不能单独使用!
		被finally修饰的代码块一定会执行,除非在执行前,虚拟机退出了!

		作用:
			用于关闭资源.

	9.面试题:
		1.final finally finalize 三个的区别:
			final 用于修饰
				类: 不可以被继承
				方法:不可以被重写
				变量: 是一个常量, 只能赋值一次

			finally是修饰代码块,与try catch 代码一起用, 一定会执行
				作用是释放资源

			finalize: 是Object中一个方法 

		
		2.finally和return谁先执行:
			return 先建立返回路径, 然后执行finally中的代码, return 语句再彻底返回结果
			finally中的内容是无法改变return中的结果的!
			finally中不要写return语句!
	
	
	10.自定义异常:
		1.步骤:
			1.定义一个类,让它继承Exception或者RuntimeException
			2.定义有参和空参构造方法

		2.作用:
			可以通过类名区分发生异常的原因!可以有针对性的处理方式!

	11.注意事项:
		子类在重写父类方法时,只能抛出跟父类相同的异常或者子类异常,父类的方法没有抛出异常时,子类重写该方法时也不能抛异常!

	12.什么时候使用try catch 什么时候抛!
		1.如果异常发生了,还想让程序继续运行,就try catch
		2.如果异常发生时,不需要继续运行了,就throw

	

2.File类
	1.File代表的路径:
		当构造方法中传入的是文件路径时,它可以操作文件
		当传入的是文件夹路径时,它可以操作的是文件夹!

	2.构造方法:	
		File(String): 传入的是一个文件或者文件夹的路径
		File(String parent,String child): 根据两个路径拼接成的路径创建的对象
		File(File parent,String child): 两个路径拼接成一个路径

	3.路径:
		相对路径: 没有盘符的路径
		绝对路径: 有盘符的路径

	4.创建方法:	
		createNewFile(): 创建文件
		mkdir(): 创建单级文件夹
		mkdirs(): 创建多级文件夹

	5.重命名:
		renameTo(File dest): 如果两个对象是在同一个路径下的,就是改名
			如果两个对象不是在同一个路径下, 就是改名并剪切!

	6.删除:
		delete():删除文件或者文件夹, 如果是删除文件夹,文件夹必须是空的!

	7.判断功能:
		isFile(): 判断是否是文件
		isDirectory(): 判断是否是文件夹
		exists(): 判断路径是否存在

		//以下方法为了解的
		canRead(): 判断是否可读
		canWrite(): 判断是否可写
		isHidden(): 判断是否隐藏

	8.获取功能:
		getAbsolutePath(): 获取绝对路径
		getPath(): 获取构造方法中的路径
		lastModified(): 获取文件最后修改时间的毫秒值

		getName(): 获取文件或者文件夹的名字
		length(): 获取文件的大小(这个方法不能获取文件夹的大小)
		list(): 返回的是文件夹中的所有文件或者文件夹的名字,是一个字符串数组
		listFiles(): 返回文件夹中的所有的文件或者文件夹的对象的数组, 得到的是File数组

	9.文件名过滤器:	
		FilenameFilter(接口)
			|--accpt()

		
1.IO流:
	1.IO流的分类
		1.按流向划分:
			输入流和输出流
		
		2.按操作的数据类型划分:
			字节流和字符流

	2.流的顶层父类:
		字节流:
			InputStream: 抽象类 字节输入流的顶层父类
			OutputStream:抽象类 字节输出流的顶层父类

		字符流:
			Reader: 抽象类 字符输入流的顶层父类
			Writer: 抽象类 字符输出流的顶层父类

	3.字节流的使用:

		字节输入流:

		FileInputStream fis = new FileInputStream("读入的文件路径");

		int b = fis.read(); // 读取一个字节

		fis.close();		//关闭流


		字节输出流:	

		FileOutputStream fos = new FileOutputStream("写出的文件路径");

		fos.write(97);			// 写出一个字节

		fos.close();			//关闭流

	4.如何追加写入文件:
		可以在创建输出流对象时,在构造方法中加入第二个参数, 加入true即可

	
	5.文件拷贝的方式:
		1.一次拷贝一个字节: 效率低
			FileInputStream fis = new FileInputStream("源文件");
			FileOutputStream fos = new FileOutputStream("目标文件");

			int b;	//定义一个变量

			while((b=fis.read())!=-1){
				fos.write(b);
			}

			fis.close();
			fos.close();//关闭流,释放资源

		
		2.一次性读入所有数据到内存, 再一次性写出: 弊端: 内存容易溢出
			FileInputStream fis = new FileInputStream("源文件");
			FileOutputStream fos = new FileOutputStream("目标文件");

			int len = fis.available();

			byte[] arr = new byte[len];

			fis.read(arr);	// 把源文件的数据读入到数组中

			fos.write(arr); //把数组中的内容写到输出流

			fis.close();
			fos.close();//关闭流,释放资源


		3.定义小数组(标准格式)
			FileInputStream fis = new FileInputStream("源文件");
			FileOutputStream fos = new FileOutputStream("目标文件");

			//定义一个小数组,大小一般为1024的整数倍
			byte[] arr = new byte[1024];

			//定义一个变量,记录数组中有效的字节个数
			int len;

			//不停地读写
			while((len=fis.read(arr))!=-1){
				fos.write(arr,0,len);
			}
			
			fis.close();
			fos.close();//关闭流,释放资源			


	6.带缓冲区的字节流:
		BufferedInputStream(InputStream)
		BufferedOutputStream(OutputStream)
			自带的缓冲区大小是8192个字节
		
		一次只能读写一个字节的时候,使用带缓冲区的流效率更高!

	7.flush方法与close方法的区别:	
		flush方法是把缓冲区中的数据刷新到文件中, 可以多次调用
		close方法作用是关闭流, 在关闭流前会把缓冲区中的内容刷新到文件中,只能调用一次!

	8.字节流读写中文:
		字节流读取中文可能会出现乱码,读到半个中文!
		字节流是可以完美地写出中文的,没有任何问题!

	9.JDK1.6以前的流的标准异常代码
		InputStream is = null;
		OutputStream os = null;

		try {
			is = new FileInputStream("a.txt");
			os = new FileOutputStream("b.txt");

			byte[] arr = new byte[1024 * 8];

			int len;

			while ((len = is.read(arr)) != -1) {
				os.write(arr, 0, len);
			}

		} finally {

			try {
				if (is != null) {
					is.close();
				}
			} finally {
				if (os != null)
					os.close();
			}
		}


	10.JDK1.7之后的标准异常代码(了解)

	11.注意事项:
		在键盘录入中的反斜杠没有转义的效果!

	1.字符流
	1.字符流的顶层父类:
		Reader:
			FileReader:
				read(): 返回的是一个int值,但是表示的是一个字符

		Writer: (有一个2KB的小缓冲区)
			FileWriter:
				write(String): 把一个字符串写到文件中
				write(int): 把一个字符写到文件中
			
	2.字符流的拷贝:
		1.一次读写一个字符: 效率低!
			FileReader fr = new FileReader("a.txt");
			FileWriter fw = new FileWriter("b.txt");

			int c;

			while((c = fr.read())!=-1){
				fw.write(c);
			}

			fr.close();
			fw.close();

		2.定义小数组
			FileReader fr = new FileReader("a.txt");
			FileWriter fw = new FileWriter("b.txt");

			char[] arr = new  char[1024];
			int len;

			while((len=fr.read(arr))!=-1){
				fw.write(arr,0,len);
			}

			fr.close();
			fw.close();


	3.什么时候使用字符流:
		1.如果只是拷贝文件,不管是什么内容,都用字节流

		2.只读或者只写文本文件的时候使用字符流

	4.字符流是不能拷贝非纯文本文件的!

	5.带缓冲区的字符流:
		BufferedReader:
			readLine(): 读取一行文本内容, 以换行符作为结束标记

		BufferedWriter:
			newLine(): 写出一个换行符. 这个方法具有跨平台性, 可以根据不同的系统写出不同的换行符!
						而 \r\n 只在windows有效!

	6.LineNumberReader:(了解)
		带行号的缓冲区字符流

	
	7.装饰设计模式:(了解)
		1.设计模式就是套路

		2.步骤:
			1.定义一个类, 在成员位置声明一个需要被装饰的类的引用

			2.通过构造方法,传入被装饰的类的对象

			3.写一个与被装饰的类中相同的方法, 调用原来对象中的该方法,然后对其进行增强!

		3.好处:
			概对原有的类进行功能上的增强, 又避免了继承的弊端:耦合性过强!


2.其他内容
	1.转换流:
		InputStreamReader(FileInputStream,编码表): 字节转字符的桥梁
		OutputStreamWriter(FileOutputStream,编码表): 字符转字节的桥梁

	2.作用:
		可以指定读写的编码表

3.递归
	1.什么是递归:
		方法自己调用自己

	2.好处:
		可以使用简单代码实现复杂的逻辑

	3.弊端:
		容易栈内存溢出

1.IO流中的其他流
	1.序列流:(了解)
		作用: 可以把多个字节输入流合并成一个!

		通过构造方法,把两个输入流合并成一个!

		通过把多个输入流存储到Vector集合中,转换成枚举,再传入序列流的构造方法中,可以实现合并多个输入流!

	2.内存输出流:
		作用: 可以把文本文件全部读取到内存,再一次性转换成字符串,可以避免出现乱码!

		弊端: 内存容易溢出!

		不需要关闭流!


	3.随机访问流:(了解)
		RandomAccessFile: 可以指定读写的位置
			作用: 用于多线程下载, 或者断点续传!
			
			自带续写功能!

			seek(index): 设置读写的位置

	
	4.对象操作流:(了解)
		1.对象输出流: ObjectOutputStream
			writeObject(Object)

			写出的对象必须要实现Serializable接口

		2.对象输入流: ObjectInputStream
			readObject(): 把对象从文件中读取回来, 调用一次就读取一个对象,有几个对象就调用几次!

		3.关于ID:
			ID的作用是标识当前字节码的版本!

	5.数据输入输出流(了解)

	6.打印流:(重点了解)
		PrintStream:
			打印字节流
		PrintWriter:
			打印字符流

		可以指定是否自动刷出,通过构造方法

		打印流只操作数据目的,不操作数据源!

	7.标准输入输出流:(了解)
		标准输入流: System.in 默认指向的是键盘
		标准输出流: System.out 默认指向的是控制台

		System.setIn(输入流): 设置标准输入流的指向
		System.setOut(输出流): 设置标准输出流的指向

		
	8.键盘录入的两种方式:(了解)
		1.Scanner类

		2.使用BufferedReader包装InputStreamReader, 再包装System.in


2.Properties类(了解)
	是一个Map集合的子类,它的父类是Hashtable

	这个集合没有泛型, 存储的都是String
	
	特有的方法:
		setProperty(key,value)
		getProperty(key)
		propertyNames(): 返回所有键的枚举


	load(字节输入流): 把文件中的数据加载进集合中
	store(字节输出流,"注释"): 把集合中的数据存储到文件中! 


